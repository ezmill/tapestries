<html style="visibility: visible;"><head>
<script src="js/three.min.js"></script><style type="text/css"></style>
<script src="js/OrbitControls.js"></script>
<script src="js/FirstPersonControls.js"></script>
<script src="js/PointerLockControls.js"></script>
<script src="js/OBJLoader.js"></script>
<script src="js/SceneLoader.js"></script>
<!--<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>-->
<style>
body{
	padding: 0px;
	margin: 0px;

}
</style>
</head>
<body cz-shortcut-listen="true">
<!-- <div id="container"><canvas width="1440" height="734" style="width: 1440px; height: 734px;"></canvas></div> -->

<script id="passThrough" type="x-shader/x-fragment">
		varying vec2 vUv;
		uniform sampler2D tex;

		void main() {
			gl_FragColor = texture2D(tex, vUv);
		}
</script>

<script id="fxaa" type="x-shader/x-fragment">
		uniform sampler2D tDiffuse;
		uniform vec2 resolution;

		#define FXAA_REDUCE_MIN   (1.0/128.0)
		#define FXAA_REDUCE_MUL   (1.0/8.0)
		#define FXAA_SPAN_MAX     8.0

		void main() {

			vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;
			vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;
			vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;
			vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;
			vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );
			vec3 rgbM  = rgbaM.xyz;
			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float lumaNW = dot( rgbNW, luma );
			float lumaNE = dot( rgbNE, luma );
			float lumaSW = dot( rgbSW, luma );
			float lumaSE = dot( rgbSE, luma );
			float lumaM  = dot( rgbM,  luma );
			float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );
			float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );

			vec2 dir;
			dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
			dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

			float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );

			float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );
			dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),
				  max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
						dir * rcpDirMin)) * resolution;
			vec4 rgbA = (1.0/2.0) * (
        	texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (1.0/3.0 - 0.5)) +
			texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (2.0/3.0 - 0.5)));
    		vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (
			texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (0.0/3.0 - 0.5)) +
      		texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (3.0/3.0 - 0.5)));
    		float lumaB = dot(rgbB, vec4(luma, 0.0));

			if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {

				gl_FragColor = rgbA;

			} else {
				gl_FragColor = rgbB;

			}

		}
</script>

<script id="emboss" type="x-shader/x-fragment">
varying vec2 vUv;
uniform sampler2D u_image;
uniform float step_w;
uniform float step_h;

      vec2 offset[9];
      vec2 tc = vUv*1.25;

      void main() {
        float kernel[9];
        vec4 sum = vec4(0.0);

        offset[0] = vec2(-step_w, -step_h);
		offset[1] = vec2(0.0, -step_h);
		offset[2] = vec2(step_w, -step_h);
		offset[3] = vec2(-step_w, 0.0);
		offset[4] = vec2(0.0, 0.0);
		offset[5] = vec2(step_w, 0.0);
		offset[6] = vec2(-step_w, step_h);
		offset[7] = vec2(0.0, step_h);
		offset[8] = vec2(step_w, step_h);

		kernel[0] = 0.0; kernel[1] = 6.1; kernel[2] = 0.0;
		kernel[3] = 0.0; kernel[4] = -3.0; kernel[5] = 0.0;
		kernel[6] = 0.0; kernel[7] = -3.0; kernel[8] = 0.0;

		for (int i = 0; i < 9; i++) {
			sum += texture2D(u_image,vUv+offset[i])*(kernel[i]);
		}

		sum += texture2D(u_image, vec2(tc.x - step_w, tc.y)); //left
		sum += texture2D(u_image, vec2(tc.x + step_w, tc.y)); //right
		sum += texture2D(u_image, vec2(tc.x, tc.y - step_w)); //bottom
		sum += texture2D(u_image, vec2(tc.x, tc.y + step_h)); //top
		sum /= 6.0;

          vec4 c = sum;
    

        gl_FragColor = c+ vec4(vec3(0.009),0.0) +0.5;

      }
</script>

<script id="sharpen" type="x-shader/x-fragment">
	uniform sampler2D tex;
	varying vec2 vUv;
	varying vec3 vecPos;
	varying vec3 vecNormal;
	uniform vec2 res;
	uniform float step_w;
	uniform float step_h;

	uniform vec3 pointLightColor[MAX_POINT_LIGHTS];
	uniform vec3 pointLightPosition[MAX_POINT_LIGHTS];
	uniform float pointLightDistance[MAX_POINT_LIGHTS];

	vec3 rgb2hsv(vec3 c){
	    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
	    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
	    
	    float d = q.x - min(q.w, q.y);
	    float e = 1.0e-10;
	    return vec3(abs(( (q.z + (q.w - q.y) / (6.0 * d + e))) ), d / (q.x + e), q.x);
	}

	vec3 hsv2rgb(vec3 c){
	    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
	}

	vec2 texelWidth = vec2(1514.0,861.0);
	float mult = 1.0;
	void main() {
/*
		float tl = abs(texture2D(tex, vUv + texelWidth * vec2(-step_w, -step_h)).x);   // top left
    	float  l = abs(texture2D(tex, vUv + texelWidth * vec2(-step_w,  0.0)).x);   // left
    	float bl = abs(texture2D(tex, vUv + texelWidth * vec2(-step_w,  step_h)).x);   // bottom left
    	float  t = abs(texture2D(tex, vUv + texelWidth * vec2( 0.0, -step_h)).x);   // top
    	float  b = abs(texture2D(tex, vUv + texelWidth * vec2( 0.0,  step_h)).x);   // bottom
    	float tr = abs(texture2D(tex, vUv + texelWidth * vec2( step_w, -step_h)).x);   // top right
    	float  r = abs(texture2D(tex, vUv + texelWidth * vec2( step_w,  0.0)).x);   // right
    	float br = abs(texture2D(tex, vUv + texelWidth * vec2( step_w,  step_h)).x);   // bottom right

    	float dX = tr*mult + 2.0*r*mult + br*mult -tl*mult - 2.0*l*mult - bl*mult;
    	float dY = bl*mult + 2.0*b*mult + br*mult -tl*mult - 2.0*t*mult - tr*mult;

    	float blur = t + b + l + r;
    	blur /= 4.0;

    	vec3 col = normalize(vec3(dX,dY,1.0/2.0)+(blur*0.25));//*blur;
    	col *= 0.5;
    	col += 0.5;
*/


		
	  vec4 addedLights = vec4(vec3(0.0),1.0);
	  float shin = 100.0;

	  for(int i = 0; i< MAX_POINT_LIGHTS; i++){
	  	vec3 lightDirection = normalize(vecPos - pointLightPosition[i]);
	  	float D = length( lightDirection);
	  	vec3 falloff = vec3(0.01,0.25,1.0);
	  	vec3 N = normalize(pointLightColor[i]);
	  	vec3 L = normalize(lightDirection);

	    float attenuation = 1.0 / (falloff.x + (falloff.y*D) + (falloff.z*D*D) );

	  	float sf = max(0.0,dot(N,L));
	  	sf = pow(sf, shin);
	  	//float spec = pow(max(0.0,dot(N, normalize(pointLightColor[i] + lightDirection))), shin);
	  	addedLights.rgb += clamp((pointLightColor[i]) * max(dot(N, L), 0.0),0.0,1.0);

	  	//addedLights.rgb += clamp(dot(-lightDirection, vecNormal),0.0,1.0)*(pointLightColor[i]);
	  	addedLights.rgb += sf;
	  	addedLights *= attenuation;
	  }
		
	  float zoom = 1.0;
	  vec2 pos = (vUv - vec2(0.5,0.5)) * (zoom) + vec2(0.5);

	  vec2 sharpenOffset = vec2(step_w, step_h)*0.01;
	  vec4 color = texture2D(tex, pos)*(addedLights);

	  //blur
	  color += texture2D(tex, vec2(vUv.x - step_w, vUv.y)); //left
	  color += texture2D(tex, vec2(vUv.x + step_w, vUv.y)); //right
	  color += texture2D(tex, vec2(vUv.x, vUv.y - step_w)); //bottom
	  color += texture2D(tex, vec2(vUv.x, vUv.y + step_h)); //top
	  color /= 6.0;

	  //emboss or sharpen
	  color += texture2D(tex, vec2(vUv.x, vUv.y)-sharpenOffset); //bottom
	  color -= texture2D(tex, vec2(vUv.x, vUv.y) + sharpenOffset*-100.0); //top

	  //reduce color if all white
	  float avg = (color.r+color.g+color.b)/3.0;
	  //color = avg < 0.45 ? color+0.1 : color;
	  color = avg > 0.65 ? color-0.1 : color;

	  vec3 hsv = rgb2hsv(color.rgb );
	  hsv.r +=0.1;
	  hsv.r = mod(hsv.r, 1.0);
	  //hsv.g += 0.001;
	  //hsv.g = mod(hsv.g, 1.0);
	  hsv.b += 0.1;
	  //hsb.b = mod(hsv.b, 1.0);
	  vec3 rgb = hsv2rgb(hsv);

	  gl_FragColor =  vec4(color) + (addedLights*0.3);
	}
</script>

<script id="vertexShader" type="x-shader/x-vertex">
		varying vec2 vUv;
		varying vec3 vecPos;
		varying vec3 vecNormal;

		vec4 zoom = vec4(1.005,1.005,1.0,1.0);
		void main() {
			vUv = uv;
			vecPos = (modelMatrix * vec4(position, 1.0)).xyz;
			vecNormal = (modelMatrix * vec4(normal, 0.0)).xyz;
			gl_Position =  projectionMatrix * viewMatrix * vec4( vecPos, 1.0 );

		}
</script>
<script id="diffFs">
uniform sampler2D texture;
uniform sampler2D texture2;
uniform sampler2D texture3;
varying vec2 vUv;

void main() {
  vec4 tex0 = texture2D(texture, vUv);
  vec4 tex1 = texture2D(texture2, vUv);
  vec4 tex2 = texture2D(texture3, vUv);

  vec4 fc = (tex2 - tex1);
  float avg = dot(tex2.rgb - tex1.rgb, vec3(1.0))/3.0;
  // fc = avg <= 0.01  ? fc : 1.0-fc;
  vec4 add = (fc + tex0);
  gl_FragColor = (fc);//mod(add,tex2.r);
  // gl_FragColor = smoothstep(tex2,tex0,mod(add,tex2.r));
}
</script>
<script type="x-shader/x-fragment" id="fbFs">
varying vec2 vUv;
uniform sampler2D texture;
uniform sampler2D texture2;


void main(){

    vec2 tc = vUv;
    vec4 look = texture2D(texture,tc);//sample repos texture
    vec2 offs = vec2(look.y-look.x,look.w-look.z)*vec2(0.009, 0.0005);
    vec2 coord = offs+tc;  //relative coordinates
    
    vec4 repos = texture2D(texture, coord);
    
    gl_FragColor = repos;    
} 

</script>
<script id="flowFs">
   
    uniform vec2 resolution;
    uniform float time;
    uniform sampler2D texture;
    varying vec2 vUv;
    uniform float mouseX;
    uniform float mouseY;

    void main( void ){
      vec2 p = gl_FragCoord.xy / resolution.xy;
      
      // vec2 uv = p*0.15 + 0.25;
      vec2 uv = vUv;
      // vec2 uv = vUv*0.05 + vec2(0.62, 0.57);
      
      vec2 e = 1.0/resolution.xy;
      
      
       float am1 = 0.5*sin( time );
      // float am1 = 3.333;
       float am2 = 0.5*cos( time );
      // float am2 = 10.0;
      
      for( int i=0; i<25; i++ ){
        float h  = dot( texture2D(texture, uv             ).xyz, vec3(0.333) );
        float h1 = dot( texture2D(texture, uv+vec2(e.x,mouseX)).xyz, vec3(0.333) );
        float h2 = dot( texture2D(texture, uv+vec2(mouseY,e.y)).xyz, vec3(0.333) );
            // gradient
        vec2 g = 0.00075*vec2( (h1-h), (h2-h) )/e;
            // isoline    
        // vec2 f = g.yx*vec2(-1.0,1.0);
        vec2 f = g.yx*vec2(10.0*mouseX, 10.0*mouseY);
        
        g = mix( g, f, 0.5 );
        
        uv -= 0.000075*g;
      }
      
      vec3 col = texture2D(texture, uv).xyz;
      
        col *= 2.0;
        
      gl_FragColor = vec4(col, 1.0);
    }
</script>
<script id="chromaFs">
    uniform sampler2D texture;
    uniform float time; // seconds
    varying vec2 vUv;
    uniform vec2 resolution;
    uniform float mouseX;
    uniform float mouseY;

    void main(void) {
      float   centerBuffer    = 0.0,
      vignetteStrength  = 0.0,
      aberrationStrength  = 1.2;
      
      float   chrDist,
      vigDist;
      
      vec2 uv = vUv;
      
      //calculate how far each pixel is from the center of the screen
      vec2 vecDist = uv - ( 0.5 , 0.5 );
      chrDist = vigDist = length( vecDist );
      
      //modify the distance from the center, so that only the edges are affected
      chrDist -= centerBuffer;
      if( chrDist < 0.0 ) chrDist = 0.0;
      
      //distort the UVs
      vec2 uvR = uv * ( 1.0 + chrDist * 0.02 * aberrationStrength ),
      uvB = uv * ( 1.0 - chrDist * 0.02 * aberrationStrength );
      
      //get the individual channels using the modified UVs
      vec4 c;
      
      c.x = texture2D( texture , uvR ).x;
      c.y = texture2D( texture , uv ).y;
      c.z = texture2D( texture , uvB ).z;
      
      //apply vignette
      c *= 1.0 - vigDist* vignetteStrength;
      
      gl_FragColor = c;
    }
</script>
  <script id="chromaFs2">
    uniform sampler2D texture;
    uniform float time; // seconds
    varying vec2 vUv;
    uniform vec2 resolution;
    uniform float mouseX;
    uniform float mouseY;
//note: http://glsl.heroku.com/e#3290.7
// copied from Little Grasshopper
// Given a vec2 in [-1,+1], generate a texture coord in [0,+1]
vec2 barrelDistortion( vec2 p, vec2 amt )
{
    p = 2.0*p-1.0;
    //float BarrelPower = 1.125;
    const float maxBarrelPower = 3.0;
    float theta  = atan(p.y, p.x);
    float radius = length(p);
    radius = pow(radius, 1.0 + maxBarrelPower * amt.x);
    p.x = radius * cos(theta);
    p.y = radius * sin(theta);

    return 0.5 * ( p + 1.0 );
}


float sat( float t )
{
  return clamp( t, 0.0, 1.0 );
}

float linterp( float t ) {
  return sat( 1.0 - abs( 2.0*t - 1.0 ) );
}

float remap( float t, float a, float b ) {
  return sat( (t - a) / (b - a) );
}

vec3 spectrum_offset( float t ) {
  vec3 ret;
  float lo = step(t,0.5);
  float hi = 1.0-lo;
  float w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );
  ret = vec3(lo,1.0,hi) * vec3(1.0-w, w, 1.0-w);

  return pow( ret, vec3(1.0/2.2) );
}

float nrand( vec2 n )
{
  return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);
}

const int num_iter = 16;
const float reci_num_iter_f = 1.0 / float(num_iter);
const float gamma = 1600.0;

vec3 lin2srgb( vec3 c )
{
    return pow( c, vec3(gamma) );
}
vec3 srgb2lin( vec3 c )
{
    return pow( c, vec3(1.0/gamma));
}


void main()
{ 
  vec2 uv = vUv;
    
    const float MAX_DIST_PX = 160.0;
    float max_distort_px = MAX_DIST_PX * (1.0-mouseX/resolution.x);
  vec2 max_distort = vec2(max_distort_px) / resolution.xy;

    vec2 oversiz = barrelDistortion( vec2(1,1), max_distort );
    uv = 2.0 * uv - 1.0;
  uv = uv / (oversiz*oversiz);
  uv = 0.5 * uv + 0.5;
    
  vec3 sumcol = vec3(0.0);
  vec3 sumw = vec3(0.0);
    float rnd = nrand( uv + fract(time) );
  for ( int i=0; i<num_iter;++i )
  {
    float t = (float(i)+rnd) * reci_num_iter_f;
    vec3 w = spectrum_offset( t );
    sumw += w;
    sumcol += w * srgb2lin(texture2D( texture, barrelDistortion(uv, max_distort*t ) ).rgb);
  }
    
    sumcol.rgb /= sumw;
  
    vec3 outcol = lin2srgb(sumcol.rgb);
    outcol += rnd/255.0;
    
  gl_FragColor = vec4( outcol, 1.0);
}
</script>
<script id="blurFrag" type="x-shader/x-fragment">
uniform sampler2D texture;
uniform vec2 resolution;
uniform float mouseX;
uniform float mouseY;

varying vec2 vUv;

void main() {
  float step_w = 1.0/resolution.x;
  float step_h = 1.0/resolution.y;
  vec2 tc = vUv;
  vec4 input0 = texture2D(texture,tc);
   
  vec2 x1 = vec2(step_w, 0.0);
  vec2 y1 = vec2(0.0, step_h);
    
  input0 += texture2D(texture, tc+x1); // right
  input0 += texture2D(texture, tc-x1); // left
  input0 += texture2D(texture, tc+y1); // top
  input0 += texture2D(texture, tc-y1); // bottom

  input0 *=0.2;

  gl_FragColor = input0;
}
</script>
<script id="sharpenFrag" type="x-shader/x-fragment">
uniform sampler2D texture;
uniform vec2 resolution;
uniform float mouseX;
uniform float mouseY;

varying vec2 vUv;
float kernel[9];
vec2 offset[9];
void main() {
  float step_w = 1.0/resolution.x;
  float step_h = 1.0/resolution.y;
  vec2 tc = vUv;
  vec4 input0 = texture2D(texture,tc);
   
  // kernel[0] = -2.0; kernel[1] = -1.0; kernel[2] = 0.0;
  // kernel[3] = -1.0; kernel[4] = 1.0; kernel[5] = 1.0;
  // kernel[6] = 0.0; kernel[7] = 1.0; kernel[8] = 2.0; 
  kernel[0] = -1.0; kernel[1] = -1.0; kernel[2] = -1.0;
  kernel[3] = -1.0; kernel[4] = 8.0; kernel[5] = -1.0;
  kernel[6] = -1.0; kernel[7] = -1.0; kernel[8] = -1.0; 


  offset[0] = vec2(-step_w, -step_h);
  offset[1] = vec2(0.0, -step_h);
  offset[2] = vec2(step_w, -step_h);
  offset[3] = vec2(-step_w, 0.0);
  offset[4] = vec2(0.0, 0.0);
  offset[5] = vec2(step_w, 0.0);
  offset[6] = vec2(-step_w, step_h);
  offset[7] = vec2(0.0, step_h);
  offset[8] = vec2(step_w, step_h);
    
  input0 += texture2D(texture, tc + offset[0]) * kernel[0];
  input0 += texture2D(texture, tc + offset[1]) * kernel[1];
  input0 += texture2D(texture, tc + offset[2]) * kernel[2];
  input0 += texture2D(texture, tc + offset[3]) * kernel[3];
  input0 += texture2D(texture, tc + offset[4]) * kernel[4];
  input0 += texture2D(texture, tc + offset[5]) * kernel[5];
  input0 += texture2D(texture, tc + offset[6]) * kernel[6];
  input0 += texture2D(texture, tc + offset[7]) * kernel[7];
  input0 += texture2D(texture, tc + offset[8]) * kernel[8];


  // input0 *=0.2;
  float kernelWeight = kernel[0] + kernel[2] + kernel[3] + kernel[4] + kernel[5] + kernel[6] + kernel[7] + kernel[8]; 

  if (kernelWeight <= 0.0) {
     kernelWeight = 1.0;
   }
  gl_FragColor = vec4((input0/kernelWeight).rgb, 1.0);
}
</script>
<script id="embossFrag" type="x-shader/x-fragment">
uniform sampler2D texture;
uniform vec2 resolution;
uniform float mouseX;
uniform float mouseY;

varying vec2 vUv;
float kernel[9];
vec2 offset[9];
void main() {
  float step_w = 1.0/resolution.x;
  float step_h = 1.0/resolution.y;
  vec2 tc = vUv;
  vec4 input0 = texture2D(texture,tc);
   
  kernel[0] = -2.0; kernel[1] = -1.0; kernel[2] = 0.0;
  kernel[3] = -1.0; kernel[4] = 1.0; kernel[5] = 1.0;
  kernel[6] = 0.0; kernel[7] = 1.0; kernel[8] = 2.0; 
  // kernel[0] = -1.0; kernel[1] = -1.0; kernel[2] = -1.0;
  // kernel[3] = -1.0; kernel[4] = 8.0; kernel[5] = -1.0;
  // kernel[6] = -1.0; kernel[7] = -1.0; kernel[8] = -1.0; 


  offset[0] = vec2(-step_w, -step_h);
  offset[1] = vec2(0.0, -step_h);
  offset[2] = vec2(step_w, -step_h);
  offset[3] = vec2(-step_w, 0.0);
  offset[4] = vec2(0.0, 0.0);
  offset[5] = vec2(step_w, 0.0);
  offset[6] = vec2(-step_w, step_h);
  offset[7] = vec2(0.0, step_h);
  offset[8] = vec2(step_w, step_h);
    
  input0 += texture2D(texture, tc + offset[0]) * kernel[0];
  input0 += texture2D(texture, tc + offset[1]) * kernel[1];
  input0 += texture2D(texture, tc + offset[2]) * kernel[2];
  input0 += texture2D(texture, tc + offset[3]) * kernel[3];
  input0 += texture2D(texture, tc + offset[4]) * kernel[4];
  input0 += texture2D(texture, tc + offset[5]) * kernel[5];
  input0 += texture2D(texture, tc + offset[6]) * kernel[6];
  input0 += texture2D(texture, tc + offset[7]) * kernel[7];
  input0 += texture2D(texture, tc + offset[8]) * kernel[8];


  // input0 *=0.2;
  float kernelWeight = kernel[0] + kernel[2] + kernel[3] + kernel[4] + kernel[5] + kernel[6] + kernel[7] + kernel[8]; 

  if (kernelWeight <= 0.0) {
     kernelWeight = 1.0;
   }
  gl_FragColor = vec4((input0/kernelWeight).rgb, 1.0);
}
</script>
<script id="colorFs">
uniform sampler2D texture;
varying vec2 vUv;
uniform float mouseX;
uniform float mouseY;

vec3 rainbow(float h) {
  h = mod(mod(h, 1.0) + 1.0, 1.0);
  float h6 = h * 6.0;
  float r = clamp(h6 - 4.0, 0.0, 1.0) +
    clamp(2.0 - h6, 0.0, 1.0);
  float g = h6 < 2.0
    ? clamp(h6, 0.0, 1.0)
    : clamp(4.0 - h6, 0.0, 1.0);
  float b = h6 < 4.0
    ? clamp(h6 - 2.0, 0.0, 1.0)
    : clamp(6.0 - h6, 0.0, 1.0);
  return vec3(r, g, b);
}

vec3 rgb2hsv(vec3 c)
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
    
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(( (q.z + (q.w - q.y) / (6.0 * d + e))) ), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}


void main(){

  vec4 tex0 = texture2D(texture, vUv);
  vec3 hsv = rgb2hsv(tex0.rgb);

  hsv.r += 0.001;
  hsv.r = mod(hsv.r, 1.0);
  hsv.g *= 1.005;
  // hsv.g = mod(hsv.g, 1.0);
  vec3 rgb = hsv2rgb(hsv); 

  gl_FragColor = vec4(rgb,1.0);
  // gl_FragColor = vec4(0.0,rgb.g,0.0,1.0);
}
</script>
<script type="x-shader/x-fragment" id="flow2">
 
    uniform vec2 resolution;
    uniform float time;
    uniform sampler2D texture;
    varying vec2 vUv;
    uniform float mouseX;
    uniform float mouseY;

    void main( void ){
      vec2 p = gl_FragCoord.xy / resolution.xy;
      
      // vec2 uv = p*0.15 + 0.25;
      vec2 uv = vUv;
      // vec2 uv = vUv*0.05 + vec2(0.62, 0.57);
      
      vec2 e = 1.0/resolution.xy;
      
      
      // float am1 = 0.5 + 0.5*sin( time );
      float am1 = 0.5 + 0.5*0.927180409;
      // float am2 = 0.5 + 0.5*cos( time );
      float am2 = 10.0;
      
      for( int i=0; i<20; i++ ){
        float h  = dot( texture2D(texture, uv,               -100.0).xyz, vec3(0.333) );
        float h1 = dot( texture2D(texture, uv+vec2(e.x,mouseX), -100.0).xyz, vec3(0.333) );
        float h2 = dot( texture2D(texture, uv+vec2(mouseY,e.y), -100.0).xyz, vec3(0.333) );
            // gradient
        vec2 g = 0.001*vec2( (h1-h), (h2-h) )/e;
            // isoline    
        // vec2 f = g.yx*vec2(-1.0,1.0);
        vec2 f = g.yx*vec2(3.0*mouseX, 3.0*mouseY);
        
        g = mix( g, f, am1 );
        
        uv -= 0.0001*g*am2;
      }
      
      vec3 col = texture2D(texture, uv).xyz;
      
        // col *= 2.0;
        
      gl_FragColor = vec4(col, 1.0);
    }
</script>
<script id="syrup-fs" type="x-fragment/x-shader">
  uniform sampler2D texture; 
  uniform float time; // seconds
  varying vec2 vUv;
  uniform vec2 resolution;
  float luminanceThreshold = 0.5; // 0.2
  float colorAmplification = 1.05; // 4.0
  float effectCoverage = 1.0; // 0.5
  mat2 m = mat2( 0.10,  4.60, -3.60,  0.80 );
  float hash( float n )
  {
      return fract(sin(n)*43758.5453);
  }

  float noise( in vec2 x )
  {
      vec2 p = floor(x+sqrt(time/1.));
      vec2 f = fract(x+sqrt(time/1.));
      f = f*f*(3.0-2.0*f);
      float n = p.x + p.y*57.0;
      float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);
      return res;
  }
  float fbm( vec2 p )
  {
      float f = 0.0;
      f += 0.90000*noise( p ); p = m*p*2.02;
      f += 0.25000*noise( p ); p = m*p*2.03;
      f += 0.12500*noise( p ); p = m*p*2.01;
      f += 0.06250*noise( p ); p = m*p*2.04;
      f += 0.03125*noise( p );
      return f/0.984375;
  }
  void main() {
    vec4 finalColor;
    // Set effectCoverage to 1.0 for normal use.  

      vec2 uv;           
      uv.x = 0.4*sin(time*500.0);                                 
      uv.y = 0.4*cos(time*500.0);                                 
      vec3 c = texture2D(texture, vUv).rgb;
    
      float luma = dot(vec3(0.30, 0.59, 0.11), c);
      if (luma < luminanceThreshold)
        c *= colorAmplification; 
      // vec3 visionColor = vec3((gl_FragCoord.xy/res.xy)+1.0, 0.5*sin(time));
      // visionColor *= vec3(0.1, 0.95, 0.2);
      // visionColor *= vec3((gl_FragCoord.xy/res.xy)-2.0, 0.7*cos(time));
      finalColor.rgb = (c); //* visionColor;

    float stepSize = 0.02;
    float lum = length(texture2D(texture, vUv).rgb);
     

    // gl_FragColor = vec4(0.125,0.125,0.125,0.0);
    // gl_FragColor = vec4(0.);
    gl_FragColor = finalColor;
    // gl_FragColor = vec4(0.0,0.2, 0.0, 1.0);
     
    if (lum < 1.00) {
        if (mod(gl_FragCoord.x + gl_FragCoord.y, stepSize) == 0.0) {
            gl_FragColor = finalColor;
        }
    }
     
    if (lum < 0.75) {
        if (mod(gl_FragCoord.x - gl_FragCoord.y, stepSize) == 0.0) {
            gl_FragColor = finalColor;
        }
    }
     
    if (lum < 0.50) {
        if (mod(gl_FragCoord.x + gl_FragCoord.y, stepSize) == 0.0) {
            gl_FragColor = finalColor;
        }
    }
     
    if (lum < 0.3) {
        if (mod(gl_FragCoord.x - gl_FragCoord.y, stepSize) == 0.0) {

            gl_FragColor = finalColor;
        }
    }
    if (lum < 0.125) {
        if (mod(gl_FragCoord.x - gl_FragCoord.y, stepSize) == 0.0) {
            gl_FragColor = finalColor;
        }
    }
  }
</script>

<script id="syrup-fs-2" type="x-fragment/x-shader">
  uniform sampler2D texture; 
  uniform float time; // seconds
  varying vec2 vUv;
  uniform vec2 resolution;
  uniform float mouseX;
  uniform float mouseY;

  float kernel[9];
  float kernel2[9];
  float kernel3[9];


  vec2 offset[9];
  vec2 offset2[9];
  vec2 offset3[9];


  uniform float step_w;
  uniform float step_h;

  mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );

  float hash( float n )
  {
      return fract(sin(n)*43758.5453);
  }

  float noise( in vec2 x )
  {
      vec2 p = floor(x+sqrt(time/1.));
      vec2 f = fract(x+sqrt(time/1.));
      f = f*f*(3.0-2.0*f);
      float n = p.x + p.y*57.0;
      float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);
      return res;
  }
  float fbm( vec2 p )
  {
      float f = 0.0;
      f += 0.90000*noise( p ); p = m*p*2.02;
      f += 0.25000*noise( p ); p = m*p*2.03;
      f += 0.12500*noise( p ); p = m*p*2.01;
      f += 0.06250*noise( p ); p = m*p*2.04;
      f += 0.03125*noise( p );
      return f/0.984375;
  }
  void main() {

      offset[0] = vec2(-step_w, -step_h);
      offset[1] = vec2(0.0, -step_h);
      offset[2] = vec2(step_w, -step_h);
      offset[3] = vec2(-step_w, 0.0);
      offset[4] = vec2(0.0, 0.0);
      offset[5] = vec2(step_w, 0.0);
      offset[6] = vec2(-step_w, step_h);
      offset[7] = vec2(0.0, step_h);
      offset[8] = vec2(step_w, step_h);
      
      vec2 step2 = 1.0/(resolution*mouseX);
      offset2[0] = vec2(-step2.x, -step2.y);
      offset2[1] = vec2(0.0, -step2.y);
      offset2[2] = vec2(step2.x, -step2.y);
      offset2[3] = vec2(-step2.x, 0.0);
      offset2[4] = vec2(0.0, 0.0);
      offset2[5] = vec2(step2.x, 0.0);
      offset2[6] = vec2(-step2.x, step2.y);
      offset2[7] = vec2(0.0, step2.y);
      offset2[8] = vec2(step2.x, step2.y);

      vec2 step3 = 1.0/(resolution*mouseY);
      offset3[0] = vec2(-step3.x, -step3.y);
      offset3[1] = vec2(0.0, -step3.y);
      offset3[2] = vec2(step3.x, -step3.y);
      offset3[3] = vec2(-step3.x, 0.0);
      offset3[4] = vec2(0.0, 0.0);
      offset3[5] = vec2(step3.x, 0.0);
      offset3[6] = vec2(-step3.x, step3.y);
      offset3[7] = vec2(0.0, step3.y);
      offset3[8] = vec2(step3.x, step3.y);



      kernel[0] = 0.0; kernel[1] = -1.0; kernel[2] = 0.0;
      kernel[3] = -1.0; kernel[4] = 7.0; kernel[5] = -1.0;
      kernel[6] = 0.0; kernel[7] = -1.0; kernel[8] = 0.2;

      // kernel[0] = 0.0; kernel[1] = -0.2; kernel[2] = 0.0;
      // kernel[3] = -0.2; kernel[4] = 1.0; kernel[5] = -0.2;
      // kernel[6] = 0.0; kernel[7] = -0.2; kernel[8] = 0.0;
      kernel2[0] = -1.0; kernel2[1] = -1.0; kernel2[2] = -1.0;
      kernel2[3] = -1.0; kernel2[4] = 16.0; kernel2[5] = -1.0;
      kernel2[6] = -1.0; kernel2[7] = -1.0; kernel2[8] = -1.0;

      kernel3[0] = 1.0; kernel3[1] = 2.0; kernel3[2] = 1.0;
      kernel3[3] = 2.0; kernel3[4] = 4.0; kernel3[5] = 2.0;
      kernel3[6] = 1.0; kernel3[7] = 2.0; kernel3[8] = 1.0;
      
      // vec4 sum = vec4(0.0);
      vec4 sum = texture2D(texture, vUv)*0.92;
      //int i;
      // for (int i = 0; i < 9; i++) {
      //     vec4 color = texture2D(texture, vUv + offset[i]);
      //     sum += color * kernel[i];
      //     // sum += color * kernel2[i];
      // }

      sum += texture2D(texture, vUv + offset[0]) * kernel[0];
      sum += texture2D(texture, vUv + offset[1]) * kernel[1];
      sum += texture2D(texture, vUv + offset[2]) * kernel[2];
      sum += texture2D(texture, vUv + offset[3]) * kernel[3];
      sum += texture2D(texture, vUv + offset[4]) * kernel[4];
      sum += texture2D(texture, vUv + offset[5]) * kernel[5];
      sum += texture2D(texture, vUv + offset[6]) * kernel[6];
      sum += texture2D(texture, vUv + offset[7]) * kernel[7];
      sum += texture2D(texture, vUv + offset[8]) * kernel[8];
      sum/=9.0;
      sum += texture2D(texture, vUv + offset2[0]) * kernel2[0];
      sum += texture2D(texture, vUv + offset2[1]) * kernel2[1];
      sum += texture2D(texture, vUv + offset2[2]) * kernel2[2];
      sum += texture2D(texture, vUv + offset2[3]) * kernel2[3];
      sum += texture2D(texture, vUv + offset2[4]) * kernel2[4];
      sum += texture2D(texture, vUv + offset2[5]) * kernel2[5];
      sum += texture2D(texture, vUv + vec2(fbm(offset2[6]))) * kernel2[6];
      // sum += texture2D(texture, vUv + offset2[7]) * kernel2[7];
      sum += texture2D(texture, vUv + offset2[8]) * kernel2[8];
      // sum /= 9.0;
      sum += texture2D(texture, vUv + offset3[0]) * kernel3[0];
      sum += texture2D(texture, vUv + offset3[1]) * kernel3[1];
      sum += texture2D(texture, vUv + offset3[2]) * kernel3[2];
      sum += texture2D(texture, vUv + offset3[3]) * kernel3[3];
      sum += texture2D(texture, vUv + offset3[4]) * kernel3[4];
      sum += texture2D(texture, vUv + offset3[5]) * kernel3[5];
      sum += texture2D(texture, vUv + offset3[6]) * kernel3[6];
      sum += texture2D(texture, vUv + offset3[7]) * kernel3[7];
      sum += texture2D(texture, vUv + offset3[8]) * kernel3[8];
      // sum /= 9.0;




      float kernelWeight =
       kernel[0] +
      kernel2[0] +
      kernel3[0] +
       kernel[1] +
      kernel2[1] +
      kernel3[1] +
       kernel[2] +
      kernel2[2] +
      kernel3[2] +
       kernel[3] +
      kernel2[3] +
      kernel3[3] +
       kernel[4] +
      kernel2[4] +
      kernel3[4] +
       kernel[5] +
      kernel2[5] +
      kernel3[5] +
       kernel[6] +
      kernel2[6] +
      kernel3[6] +
       kernel[7] +
      kernel2[7] +
      kernel3[7] +
       kernel[8];
      kernel2[8] +
      kernel3[8];
     if (kernelWeight <= 0.0) {
       kernelWeight = 1.0;
     }
    gl_FragColor = vec4((sum/kernelWeight).rgb, 1.0);
  }
</script>
<script id="sineFs">
  precision highp float;
  uniform sampler2D texture;
  uniform sampler2D texture2;
  uniform sampler2D texture3;
  uniform float time;
  varying vec2 vUv;
  void main() {
    float s = vUv.s;
    float t = vUv.t;
    vec4 color = texture2D(texture2, (vec2((vUv.x*-1.)+(1.),vUv.y) + vec2(sin((time*1.0)+t*40.)*0.03*cos(time*20.0+t*2.0)*1.2, cos((time*100.0)+s*40.)*0.003)));
    vec4 input0 = texture2D(texture, vec2((vUv.x*-1.)+(1.),vUv.y));
    vec4 input2 = texture2D(texture3, vec2((vUv.x*-1.)+(1.),vUv.y));

    vec4 a = color;
    // a = dot(a.rgb, vec3(1.0))/3.0 <0.8 ? a : input2; //v important, this does the overlay

    gl_FragColor = a;
  }
</script>
<script id="fs" type="x-fragment/x-shader">
uniform sampler2D texture; 
uniform float time; // seconds
varying vec2 vUv;
uniform vec2 resolution;

void main() {
    gl_FragColor = texture2D(texture, vUv);
}
</script>
<script id="vs" type="x-shader/x-vertex">

    varying vec2 vUv;
    uniform float time;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }
</script>
<script>
var container, scene, renderer, controls;
var scene, screenScene, baseTex, tex1, tex2, camera, screenCamera, plane, cube, sphere, shader1, light;
var w = window.innerWidth;
var h = window.innerHeight;
var wHalf = w/2;
var hHalf = h/2;
var clock = new THREE.Clock();
var camControls;
var objects = [];
var ray;
var time = Date.now();
var moveForward = false;
var moveBackward = false;
var moveLeft = false;
var moveRight = false;
var walt;
var controlsEnabled = true;
var globalUniforms = {
		time: { type: "f", value: 0.0 } ,
		resolution: {type: "v2", value: new THREE.Vector2(w,h)},
		step_w: {type: "f", value: 1/w},
		step_h: {type: "f", value: 1/h},
		mouseX: {type: "f", value: 1.0},
		mouseY: {type: "f", value: 1.0},
		tv_resolution: {type: "f", value: 640.0},
		tv_resolution_y: {type: "f", value: 1600.0}
	}
var prevTime = performance.now();
var velocity = new THREE.Vector3();

// container = document.getElementById('container');
// document.addEventListener('mousedown', onDocumentMouseDown, false);

function onDocumentMouseDown(event){
	//console.log(camControls);
}



var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

	if( havePointerLock ){
		var element = document.body;

		var pointerlockchange = function ( event ) {
			if(document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element){
				controlsEnabled = true;
				controls.enabled = true;
				console.log("controls are true");
			} else{
				controls.enabled = false;
				console.log("controls are false");
			}
		}
		var pointerlockerror = function ( event ) {
			console.log(event);
		}

		document.addEventListener( 'pointerlockchange', pointerlockchange, false );
		document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
		document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

		document.addEventListener( 'pointerlockerror', pointerlockerror, false );
		document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
		document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

		document.addEventListener('click', function(event){
			element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
			if ( /Firefox/i.test( navigator.userAgent ) ) {
				var fullscreenchange = function ( event ) {

					if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {
						document.removeEventListener( 'fullscreenchange', fullscreenchange );
						document.removeEventListener( 'mozfullscreenchange', fullscreenchange );
						element.requestPointerLock();
					}
				}

				document.addEventListener( 'fullscreenchange', fullscreenchange, false );
				document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );
				element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
				element.requestFullscreen();

			} else {
				element.requestPointerLock();
			}

		}, false );
		
	}


init();
// animate();

function init(){
	var manager = new THREE.LoadingManager();
	manager.onProgress = function ( item, loaded, total ){
		console.log(item, loaded, total);
	};	

	var onProgress = function (xhr){
		if( xhr.lengthComputable){
			var percentComplete = xhr.loaded / xhr.total * 100;
			console.log(Math.round(percentComplete, 2) + '% downloaded');
		}
	};

	var onError = function(xhr){

	};


	scene = new THREE.Scene();
	screenScene = new THREE.Scene();

	//scene.fog = new THREE.FogExp2( 0x000000, 0.9 );
	//screenScene.fog = new THREE.FogExp2( 0x000000, 0.09 );
	var ambient = new THREE.AmbientLight(0x111111);
	//scene.add(ambient);

	light = new THREE.PointLight(0xFF0040,0.7,1.0);
	light.position.set(0,400,0);
	//scene.add(light);

	var light2 = new THREE.PointLight(0x0FDFFF,0.7,1.0);
	light2.position.set(300,500,200);
	//scene.add(light2);

	var light3 = new THREE.PointLight(0xFFEE00,0.6,1.0);
	light3.position.set(-300,50,600);
	//scene.add(light3);


	var light4 = new THREE.PointLight(0xffffff,1.5,1.0);
	light4.position.set(2000,100,370);
	//scene.add(light4);

		var light5 = new THREE.PointLight(0xffffff,1.5,1.0);
	//light4.position.set(2000,100,3700);
	scene.add(light5);

	for( var i = 0; i<20; i++){
		var color = new THREE.Color(Math.random(), Math.random(), Math.random());
		var randLight = new THREE.PointLight(color,1.0,4000.1);
		var randPosX = Math.floor(Math.random()*6000 - 3000);
		var randPosY = Math.floor(Math.random()*6000 -3000);
		var randPosZ = Math.floor(Math.random()*6000 - 3000);
		randLight.position.set(randPosX, randPosY, randPosZ);
		var sphereG = new THREE.SphereGeometry(30,30,30);
		var sphereMat = new THREE.MeshPhongMaterial( { color: 0xffffff, wireframe: false, transparent: false, side:THREE.DoubleSide } );
		var sphereMesh = new THREE.Mesh(sphereG, sphereMat);
		sphereMesh.position.set(randPosX, randPosY, randPosZ);
		scene.add(randLight);
		//scene.add(sphereMesh);


	}


	tex1 = new THREE.WebGLRenderTarget( w,h, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat });
	tex2 = new THREE.WebGLRenderTarget( w,h, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat });

	var res = new THREE.Vector2(w, h);

	shader1 = new THREE.ShaderMaterial({
		uniforms: THREE.UniformsUtils.merge([
			THREE.UniformsLib['lights'],
			{
			time: { type: 'f', value: 0.0},
			tex: { type: 't', value: null},
			resolution: {type: 'v2', value: res},
			step_w: { type: 'f', value: 1.0/w},
			step_h: { type: 'f', value: 1.0/h} 
			}
		]),
		vertexShader: document.getElementById('vertexShader').textContent,
		fragmentShader: document.getElementById('sharpen').textContent,
		shading: THREE.SmoothShading,
		side: THREE.DoubleSide,
		lights: true
	});

	shader1.uniforms.tex.value = tex2;
	shader1.needsUpdate = true;

	screenCamera = new THREE.OrthographicCamera( w  / -2, w  /  2, h /  2, h / -2, -10000, 10000 );
	screenScene.add( screenCamera );

	var screenGeometry = new THREE.PlaneBufferGeometry( w,h );
	var screenMaterial = new THREE.MeshBasicMaterial( { map: tex1 } );
	var quad = new THREE.Mesh( screenGeometry, screenMaterial ); 
	screenScene.add(quad);

	//camera = new THREE.OrthographicCamera(w/-2, w/2,  h/2, h/-2, -10000, 10000);
	camera = new THREE.PerspectiveCamera(45, w/h, 0.1,40000);
	//camera.position.set(0,0,5000);
	
	//scene.add(camera);

	controls = new THREE.PointerLockControls( camera );
	scene.add(controls.getObject());

	var onKeyDown = function ( event ) {
		switch ( event.keyCode ) {
			case 38: // up
			case 87: // w
				moveForward = true;
				break;
			case 37: // left
			case 65: // a
				moveLeft = true; break;
			case 40: // down
			case 83: // s
				moveBackward = true;
				break;
			case 39: // right
			case 68: // d
				moveRight = true;
				break;
			case 32: // space
				if ( canJump === true ) velocity.y += 1050;
				canJump = false;
				break;
		}
	};
	var onKeyUp = function ( event ) {
		switch( event.keyCode ) {
			case 38: // up
			case 87: // w
				moveForward = false;
				break;
			case 37: // left
			case 65: // a
				moveLeft = false;
				break;
			case 40: // down
			case 83: // s
				moveBackward = false;
				break;
			case 39: // right
			case 68: // d
				moveRight = false;
				break;
		}
	};

	document.addEventListener( 'keydown', onKeyDown, false );
	document.addEventListener( 'keyup', onKeyUp, false );

	ray = new THREE.Raycaster(new THREE.Vector3(),new THREE.Vector3(0,-1,0),0,100);
	//ray.ray.direction.set(0,-1,0);

	var planeGeo = new THREE.PlaneBufferGeometry(w*6, w*6);
	var cubeGeo = new THREE.BoxGeometry(200,200,200);
	var sphereGeo = new THREE.SphereGeometry(50, 32, 16);
	var planeMat = new THREE.MeshBasicMaterial({map: tex2});
	var wireMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff, wireframe: false, transparent: false, side:THREE.DoubleSide } );



//floor
	plane3 = new THREE.Mesh(planeGeo, shader1);
	plane3.position.set(0,0,0);
	plane3.rotation.x = 270 * Math.PI/180;
	scene.add(plane3);


	for(var i =0; i<100; i++){
		//wireMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff, wireframe: true, transparent: false } );
		var rand = Math.floor(Math.random()*2);
		if(rand == 0){
			var cubeGeo = new THREE.BoxGeometry(200,200,200);
			var manyCubes = new THREE.Mesh(cubeGeo, shader1);
		} else {
			var cubeGeo = new THREE.PlaneBufferGeometry(200,200);

			var manyCubes = new THREE.Mesh(cubeGeo, wireMaterial);
			manyCubes.rotation.x = (Math.floor(Math.random()*10) + 90) * Math.PI/180
			manyCubes.rotation.z = (Math.floor(Math.random()*10) + 90) * Math.PI/180
		}
		manyCubes.position.x = Math.floor(Math.random()*3000 - 1500);
		manyCubes.position.y =Math.floor(Math.random()* 50) * 50 + 25;
		manyCubes.position.z = -Math.floor(Math.random()*3000 - 1500);
		scene.add(manyCubes);
		objects.push(manyCubes);
	}

	cubeGeo = new THREE.BoxGeometry(6000,6000,6000);
	var bgCube = new THREE.Mesh(cubeGeo, shader1);

	scene.add(bgCube);

	shader1.needsUpdate = true;

	// var loader = new THREE.OBJLoader( manager );
	// loader.load('js/models/cloth2.obj', function (object){
	// 	object.traverse( function (child){
	// 		if( child instanceof THREE.Mesh ){
	// 			child.material = shader1;
	// 			child.material.needsUpdate = true;

	// 		}
	// 	});

	// 	//object.material.map = shader1;
	// 	//object.material.needsUpdate = true;
	// 	object.position.set(0,0,0);
		
	// 	object.castShadow = true;
	// 	object.receiveShadow = false;
	// 	object.scale.set(10,10,10);

	// 	console.log(object);
	// 	scene.add(object);

		
	// }, onProgress, onError);


	// var loader = new THREE.JSONLoader();

	// loader.load('bust.obj', function(result){
	// 	//result.computeTangents();
	// 	walt = new THREE.Mesh(result, shader1);
	// 	shader1.needsUpdate = true;
	// 	walt.geometry.uvsNeedUpdate = true;
	// 	walt.geometry.buffersNeedUpdate = true;

	// 	walt.position.set(0,0,4000);
	// 	scene.add(walt);
	// 	console.log(result);

	// });


	//camera.lookAt(cube.position);

	sphere = new THREE.Mesh(sphereGeo, wireMaterial);
	sphere.position.set(200,0,500);
	//scene.add(sphere);

	objects.push(bgCube);

	renderer = new THREE.WebGLRenderer( {antialias: true });
	renderer.setSize(w, h);
	renderer.autoClear = true;
	renderer.context.getProgramInfoLog = function () { return '' }; //removes weird vertex attr binding error
	// container.appendChild( renderer.domElement);

	initOutputScene();
	
}

function animate(){
	// window.requestAnimationFrame(animate);
	render();
	update();
}

function update(){
	var delta = clock.getDelta();
	//controls.update();
	//camControls.update(delta)
	//camera.lookAt(cube.position);
	//camera.rotation.z = Date.now()*0.00005;
	//controls.isOnObject( false );
	if (controlsEnabled) {
		ray.ray.origin.copy( controls.getObject().position );
		ray.ray.origin.y -= 10;

		var intersections = ray.intersectObjects(objects);
		var isOnObject = intersections.length > 0;
		console.log(isOnObject);
		time = performance.now();
		var delta = ( time - prevTime) / 500;

		velocity.x -= velocity.x * 10.0 * delta;
		velocity.z -= velocity.z * 10.0 * delta;
		velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

		if ( moveForward ) velocity.z -= 3200.0 * delta;
		if ( moveBackward ) velocity.z += 3200.0 * delta;
		if ( moveLeft ) velocity.x -= 3200.0 * delta;
		if ( moveRight ) velocity.x += 3200.0 * delta;

		if ( isOnObject === true ) {
			velocity.y = Math.max( 0, velocity.y );
			canJump = true;
		}
		controls.getObject().translateX( velocity.x * delta );
		controls.getObject().translateY( velocity.y * delta );
		controls.getObject().translateZ( velocity.z * delta );
		
		if ( controls.getObject().position.y < 10 ) {
			velocity.y = 0;
			controls.getObject().position.y = 10;
			canJump = true;
		}

		prevTime = time;
	}
	//controls.update( Date.now() - time);
	
}

function render(){
	//cube.position.set(-100,Math.sin(Date.now()*0.005)*100,3000);
	light.position.set(Math.sin(Date.now()*0.0005)*2000, 100,2900);
	//sphere.position.set(Math.sin(Date.now()*0.0005)*2000, 100,2900);
	//cube.rotation.z = (Date.now()*0.005);
	renderer.render(scene, camera, tex1, true);
	renderer.render(screenScene, screenCamera, tex2, true);
	renderer.render(scene, camera);
}


function initOutputScene() {

    outputCamera = new THREE.PerspectiveCamera(50, w / h, 1, 100000);
    outputCamera.position.set(0, 0, 750);
    //different camera for render targets - interesting results when outputCameraRTT is substituted with outputCamera in the outputDraw function
    outputCameraRTT = new THREE.OrthographicCamera( w / - 2, w / 2, h / 2, h / - 2, -10000, 10000 );
    outputCameraRTT.position.z = 100;

    outputRenderer = new THREE.WebGLRenderer({preserveDrawingBuffer: true});
    outputRenderer.setSize(w, h);
    outputRenderer.setClearColor(0xffffff, 1);
    outputRenderer.setBlending(THREE.CustomBlending, THREE.SubtractEquation, THREE.DstColorFactor, THREE.SrcColorFactor);

    container = document.createElement('div');
    document.body.appendChild(container);
    container.appendChild(outputRenderer.domElement);

    outputScene = new THREE.Scene();

    //global object for common uniforms b/c lots of fragment shaders 
    // globalUniforms = {
    //     time: { type: 'f', value: time },
    //     resolution: { type: 'v2', value: new THREE.Vector2(w, h) },
    //     mouseX: { type: 'f', value: 0.0 },
    //     mouseY: { type: 'f', value: 0.0 }
    // }

    //takes input scene and makes it into a texture for frame differencing
    initInputTexture();

    //feedback loop setup
    initFrameDifferencing();

    //if you press space bar it'll take a screenshot - useful for being crazy prolific
    // document.addEventListener('keydown', onKeyDown, false);
    // document.addEventListener('mousemove', onDocumentMouseMove, false);

    outputAnimate();
}

function initInputTexture() {
    inputTexture = new THREE.Texture(renderer.domElement);;
    inputTexture.needsUpdate = true;
}

function feedbackObject(uniforms, vertexShader, fragmentShader) {
    this.scene = new THREE.Scene();
    this.renderTarget = new THREE.WebGLRenderTarget(w, h, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat});
    this.material = new THREE.ShaderMaterial({
        uniforms: uniforms, //uniforms object from constructor
        vertexShader: document.getElementById(vertexShader).textContent,
        fragmentShader: document.getElementById(fragmentShader).textContent
    });
    this.mesh = new THREE.Mesh(planeGeometry, this.material);
    this.mesh.position.set(0, 0, 0);
    this.scene.add(this.mesh);
}

function initFrameDifferencing() {
    planeGeometry = new THREE.PlaneBufferGeometry(w, h);

    feedbackObject1 = new feedbackObject({
        time: globalUniforms.time,
        resolution: globalUniforms.resolution,
        texture: { type: 't', value: inputTexture },
        mouseX: globalUniforms.mouseX,
        mouseY: globalUniforms.mouseY
    }, "vs", 
    "flow2"); //string for fragment shader id - the only lines that really matter in this function, or the only lines you'll wanna change

    feedbackObject2 = new feedbackObject({
        time: globalUniforms.time,
        resolution: globalUniforms.resolution,
        texture: { type: 't', value: feedbackObject1.renderTarget }, //use previous feedback object's texture
        texture2: { type: 't', value: inputTexture }, // p sure this line doesnt do anything lol
        mouseX: globalUniforms.mouseX,
        mouseY: globalUniforms.mouseY
    }, "vs", 
    "fs"); //these first three/four fragment shader object things are where most of the feedback loop is happening

    frameDifferencer = new feedbackObject({
        time: globalUniforms.time,
        resolution: globalUniforms.resolution,
        texture: { type: 't', value: feedbackObject1.renderTarget },
        texture2: { type: 't', value: feedbackObject2.renderTarget },
        texture3: { type: 't', value: inputTexture },
        mouseX: globalUniforms.mouseX,
        mouseY: globalUniforms.mouseY
    }, "vs", 
    "diffFs"); //differencing fs - leave this one alone

    feedbackObject3 = new feedbackObject({
        time: globalUniforms.time,
        resolution: globalUniforms.resolution,
        texture: { type: 't', value: frameDifferencer.renderTarget },
        mouseX: globalUniforms.mouseX,
        mouseY: globalUniforms.mouseY
    }, "vs", 
    "blurFrag"); //this fs also contributes to feedback loop

    feedbackObject4 = new feedbackObject({
        time: globalUniforms.time,
        resolution: globalUniforms.resolution,
        texture: { type: 't', value: feedbackObject3.renderTarget },
        mouseX: globalUniforms.mouseX,
        mouseY: globalUniforms.mouseY
    }, "vs", 
    "sharpenFrag"); //this fs is basically post-processing


    feedbackObject1.material.uniforms.texture.value = frameDifferencer.renderTarget; //previous frame as input

    outputMaterial = new THREE.MeshBasicMaterial({
        map: feedbackObject4.renderTarget
    });
    outputMesh = new THREE.Mesh(planeGeometry, outputMaterial);
    outputScene.add(outputMesh);

    rtt = new THREE.WebGLRenderTarget(w, h, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat});


}

function outputAnimate() {
    window.requestAnimationFrame(outputAnimate);
    outputDraw();
}

function outputDraw() {

    // time += 0.05;
    // inputDraw();
    animate();
    inputTexture.needsUpdate = true;

    // expand(1.001);// - similar to translateVs


    //render all the render targets to their respective scenes
    outputRenderer.render(feedbackObject2.scene, outputCameraRTT, feedbackObject2.renderTarget, true);
    outputRenderer.render(frameDifferencer.scene, outputCameraRTT, frameDifferencer.renderTarget, true);
    outputRenderer.render(feedbackObject3.scene, outputCameraRTT, feedbackObject3.renderTarget, true);
    outputRenderer.render(feedbackObject4.scene, outputCameraRTT, feedbackObject4.renderTarget, true);

    outputRenderer.render(outputScene, outputCamera);

    //get new frame
    outputRenderer.render(feedbackObject1.scene, outputCameraRTT, feedbackObject1.renderTarget, true);

    // swap buffers - this is why feedbackObject3's fragment shader contributes to feedback loop but feedbackObject3 is just post-processing i think
    var a = feedbackObject3.renderTarget;
    feedbackObject3.renderTarget = feedbackObject1.renderTarget;
    feedbackObject1.renderTarget = a;


    outputRenderer.render(outputScene, outputCamera, rtt, true);
    



}

//utility functions and event listeners
function expand(expand) {
    frameDifferencer.mesh.scale.set(1, expand, 1);
}



</script>


</body></html>